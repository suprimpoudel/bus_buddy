{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { SeriesContext } from '../context/SeriesContextProvider';\nimport { CartesianContext } from '../context/CartesianContextProvider';\nimport { BarElement } from './BarElement';\nimport { isBandScaleConfig } from '../models/axis';\n/**\n * Solution of the equations\n * W = barWidth * N + offset * (N-1)\n * offset / (offset + barWidth) = r\n * @param bandWidth The width available to place bars.\n * @param numberOfGroups The number of bars to place in that space.\n * @param gapRatio The ratio of the gap between bars over the bar width.\n * @returns The bar width and the offset between bars.\n */\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction getBandSize({\n  bandWidth: W,\n  numberOfGroups: N,\n  gapRatio: r\n}) {\n  if (r === 0) {\n    return {\n      barWidth: W / N,\n      offset: 0\n    };\n  }\n\n  const barWidth = W / (N + (N - 1) * r);\n  const offset = r * barWidth;\n  return {\n    barWidth,\n    offset\n  };\n}\n\nfunction BarPlot(props) {\n  const seriesData = React.useContext(SeriesContext).bar;\n  const axisData = React.useContext(CartesianContext);\n\n  if (seriesData === undefined) {\n    return null;\n  }\n\n  const {\n    series,\n    stackingGroups\n  } = seriesData;\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = axisData;\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  return /*#__PURE__*/_jsx(React.Fragment, {\n    children: stackingGroups.flatMap(({\n      ids: groupIds\n    }, groupIndex) => {\n      return groupIds.flatMap(seriesId => {\n        var _series$seriesId$xAxi, _series$seriesId$yAxi;\n\n        const xAxisKey = (_series$seriesId$xAxi = series[seriesId].xAxisKey) != null ? _series$seriesId$xAxi : defaultXAxisId;\n        const yAxisKey = (_series$seriesId$yAxi = series[seriesId].yAxisKey) != null ? _series$seriesId$yAxi : defaultYAxisId;\n        const xAxisConfig = xAxis[xAxisKey];\n        const yAxisConfig = yAxis[yAxisKey];\n        const verticalLayout = series[seriesId].layout === 'vertical';\n        let baseScaleConfig;\n\n        if (verticalLayout) {\n          if (!isBandScaleConfig(xAxisConfig)) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud be of type \"band\" to display the bar series of id \"${seriesId}\"`);\n          }\n\n          if (xAxis[xAxisKey].data === undefined) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud have data property`);\n          }\n\n          baseScaleConfig = xAxisConfig;\n        } else {\n          if (!isBandScaleConfig(yAxisConfig)) {\n            throw new Error(`Axis with id \"${yAxisKey}\" shoud be of type \"band\" to display the bar series of id \"${seriesId}\"`);\n          }\n\n          if (yAxis[yAxisKey].data === undefined) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud have data property`);\n          }\n\n          baseScaleConfig = yAxisConfig;\n        }\n\n        const xScale = xAxisConfig.scale;\n        const yScale = yAxisConfig.scale;\n        const bandWidth = baseScaleConfig.scale.bandwidth();\n        const {\n          barWidth,\n          offset\n        } = getBandSize({\n          bandWidth,\n          numberOfGroups: stackingGroups.length,\n          gapRatio: baseScaleConfig.barGapRatio\n        });\n        const barOffset = groupIndex * (barWidth + offset);\n        const {\n          stackedData,\n          color\n        } = series[seriesId];\n        return stackedData.map((values, dataIndex) => {\n          var _xAxis$xAxisKey$data, _yAxis$yAxisKey$data;\n\n          const baseline = Math.min(...values);\n          const value = Math.max(...values);\n          return /*#__PURE__*/_jsx(BarElement, _extends({\n            id: seriesId,\n            dataIndex: dataIndex,\n            x: verticalLayout ? xScale((_xAxis$xAxisKey$data = xAxis[xAxisKey].data) == null ? void 0 : _xAxis$xAxisKey$data[dataIndex]) + barOffset : xScale(baseline),\n            y: verticalLayout ? yScale(value) : yScale((_yAxis$yAxisKey$data = yAxis[yAxisKey].data) == null ? void 0 : _yAxis$yAxisKey$data[dataIndex]) + barOffset,\n            height: verticalLayout ? Math.abs(yScale(baseline) - yScale(value)) : barWidth,\n            width: verticalLayout ? barWidth : Math.abs(xScale(baseline) - xScale(value)),\n            color: color,\n            highlightScope: series[seriesId].highlightScope\n          }, props), `${seriesId}-${dataIndex}`);\n        });\n      });\n    })\n  });\n}\n\nprocess.env.NODE_ENV !== \"production\" ? BarPlot.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n\n  /**\n   * The props used for each component slot.\n   * @default {}\n   */\n  slotProps: PropTypes.object,\n\n  /**\n   * Overridable component slots.\n   * @default {}\n   */\n  slots: PropTypes.object\n} : void 0;\nexport { BarPlot };","map":{"version":3,"names":["_extends","React","PropTypes","SeriesContext","CartesianContext","BarElement","isBandScaleConfig","jsx","_jsx","getBandSize","bandWidth","W","numberOfGroups","N","gapRatio","r","barWidth","offset","BarPlot","props","seriesData","useContext","bar","axisData","undefined","series","stackingGroups","xAxis","yAxis","xAxisIds","yAxisIds","defaultXAxisId","defaultYAxisId","Fragment","children","flatMap","ids","groupIds","groupIndex","seriesId","_series$seriesId$xAxi","_series$seriesId$yAxi","xAxisKey","yAxisKey","xAxisConfig","yAxisConfig","verticalLayout","layout","baseScaleConfig","Error","data","xScale","scale","yScale","bandwidth","length","barGapRatio","barOffset","stackedData","color","map","values","dataIndex","_xAxis$xAxisKey$data","_yAxis$yAxisKey$data","baseline","Math","min","value","max","id","x","y","height","abs","width","highlightScope","process","env","NODE_ENV","propTypes","slotProps","object","slots"],"sources":["/Users/suprimpoudel/WebstormProjects/bus_buddy_web/node_modules/@mui/x-charts/esm/BarChart/BarPlot.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { SeriesContext } from '../context/SeriesContextProvider';\nimport { CartesianContext } from '../context/CartesianContextProvider';\nimport { BarElement } from './BarElement';\nimport { isBandScaleConfig } from '../models/axis';\n\n/**\n * Solution of the equations\n * W = barWidth * N + offset * (N-1)\n * offset / (offset + barWidth) = r\n * @param bandWidth The width available to place bars.\n * @param numberOfGroups The number of bars to place in that space.\n * @param gapRatio The ratio of the gap between bars over the bar width.\n * @returns The bar width and the offset between bars.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction getBandSize({\n  bandWidth: W,\n  numberOfGroups: N,\n  gapRatio: r\n}) {\n  if (r === 0) {\n    return {\n      barWidth: W / N,\n      offset: 0\n    };\n  }\n  const barWidth = W / (N + (N - 1) * r);\n  const offset = r * barWidth;\n  return {\n    barWidth,\n    offset\n  };\n}\nfunction BarPlot(props) {\n  const seriesData = React.useContext(SeriesContext).bar;\n  const axisData = React.useContext(CartesianContext);\n  if (seriesData === undefined) {\n    return null;\n  }\n  const {\n    series,\n    stackingGroups\n  } = seriesData;\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = axisData;\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  return /*#__PURE__*/_jsx(React.Fragment, {\n    children: stackingGroups.flatMap(({\n      ids: groupIds\n    }, groupIndex) => {\n      return groupIds.flatMap(seriesId => {\n        var _series$seriesId$xAxi, _series$seriesId$yAxi;\n        const xAxisKey = (_series$seriesId$xAxi = series[seriesId].xAxisKey) != null ? _series$seriesId$xAxi : defaultXAxisId;\n        const yAxisKey = (_series$seriesId$yAxi = series[seriesId].yAxisKey) != null ? _series$seriesId$yAxi : defaultYAxisId;\n        const xAxisConfig = xAxis[xAxisKey];\n        const yAxisConfig = yAxis[yAxisKey];\n        const verticalLayout = series[seriesId].layout === 'vertical';\n        let baseScaleConfig;\n        if (verticalLayout) {\n          if (!isBandScaleConfig(xAxisConfig)) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud be of type \"band\" to display the bar series of id \"${seriesId}\"`);\n          }\n          if (xAxis[xAxisKey].data === undefined) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud have data property`);\n          }\n          baseScaleConfig = xAxisConfig;\n        } else {\n          if (!isBandScaleConfig(yAxisConfig)) {\n            throw new Error(`Axis with id \"${yAxisKey}\" shoud be of type \"band\" to display the bar series of id \"${seriesId}\"`);\n          }\n          if (yAxis[yAxisKey].data === undefined) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud have data property`);\n          }\n          baseScaleConfig = yAxisConfig;\n        }\n        const xScale = xAxisConfig.scale;\n        const yScale = yAxisConfig.scale;\n        const bandWidth = baseScaleConfig.scale.bandwidth();\n        const {\n          barWidth,\n          offset\n        } = getBandSize({\n          bandWidth,\n          numberOfGroups: stackingGroups.length,\n          gapRatio: baseScaleConfig.barGapRatio\n        });\n        const barOffset = groupIndex * (barWidth + offset);\n        const {\n          stackedData,\n          color\n        } = series[seriesId];\n        return stackedData.map((values, dataIndex) => {\n          var _xAxis$xAxisKey$data, _yAxis$yAxisKey$data;\n          const baseline = Math.min(...values);\n          const value = Math.max(...values);\n          return /*#__PURE__*/_jsx(BarElement, _extends({\n            id: seriesId,\n            dataIndex: dataIndex,\n            x: verticalLayout ? xScale((_xAxis$xAxisKey$data = xAxis[xAxisKey].data) == null ? void 0 : _xAxis$xAxisKey$data[dataIndex]) + barOffset : xScale(baseline),\n            y: verticalLayout ? yScale(value) : yScale((_yAxis$yAxisKey$data = yAxis[yAxisKey].data) == null ? void 0 : _yAxis$yAxisKey$data[dataIndex]) + barOffset,\n            height: verticalLayout ? Math.abs(yScale(baseline) - yScale(value)) : barWidth,\n            width: verticalLayout ? barWidth : Math.abs(xScale(baseline) - xScale(value)),\n            color: color,\n            highlightScope: series[seriesId].highlightScope\n          }, props), `${seriesId}-${dataIndex}`);\n        });\n      });\n    })\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? BarPlot.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * The props used for each component slot.\n   * @default {}\n   */\n  slotProps: PropTypes.object,\n  /**\n   * Overridable component slots.\n   * @default {}\n   */\n  slots: PropTypes.object\n} : void 0;\nexport { BarPlot };"],"mappings":"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"},"metadata":{},"sourceType":"module"}